# Redis设计与实现

## 第1章 引言

### 1.1 Redis版本说明 

本书是基于Redis 3.0的开发版来编写的，

### 1.2 章节编排

本书由“数据结构与对象”、“单机数据库的实现”、“多机数据库的实现”、“独立功能的实现”四个部分组成。

### 1.3 推荐的阅读方法

多级版本用户：推荐按顺序阅读

单机版本用户：可以跳过第三部分

### 1.4 行文规则

名字引用规则：file/name格式（文件/函数）

结构引用规则：struct.property格式

算法规则：除非有额外说明，否则本书列出的算法复杂度一律为最坏情形下的算法复杂度。

代码规则：C语言和Python语言

server和client两个全局变量，其中server表示服务器状态（redis.h/redisServer结构的实例），而client则表示正在执行操作的客户端状态（redis.h/redisClient结构的实例）。

## 第一部分 数据结构与对象

### 第2章 简单动态字符串

#### 2.1 SDS的定义 

每个sds.h/sdshdr结构表示一个SDS值：

```c
struct sdshdr{
    int len;
    int free;
    // 以'\0'结尾，不计入len
    char buf[];
}
```

#### 2.2 SDS与C字符串的区别 

##### 2.2.1 常数复杂度获取字符串长度

C字符串为了获取一个C字符串的长度，必须遍历整个字符串，这个操作的复杂度为O（N）。

SDS，获取一个SDS长度的命令STRLEN，复杂度仅为O（1）。

##### 2.2.2 杜绝缓冲区溢出

C字符串容易造成缓冲区溢出（bufferoverflow）。

SDS杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作。

##### 2.2.3 减少修改字符串时带来的内存重分配次数

C字符串每次增长或者缩短一个，程序都总要对保存这个C字符串的数组进行一次内存重分配操作。

SDS实现了两种优化策略

1. 空间预分配
   1. 对SDS进行修改之后，len<1MB，那么程序分配和len属性同样大小的未使用空间，len=free。
   2. 如果对SDS进行修改之后，len>=1MB，那么程序会分配1MB的未使用空间,free=1MB。
2. 惰性空间释放
   1. SDS的字符串缩短操作：使用free属性将这些字节的数量记录起来，不释放空间。

##### 2.2.4 二进制安全

C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据

SDS的API都是二进制安全的（binary-safe），所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，**数据在写入时是什么样的，它被读取时就是什么样**。

##### 2.2.5 兼容部分C字符串函数

SDS可以在有需要时重用＜string.h＞函数库，从而避免了不必要的代码重复

##### 2.2.6 总结

![image-20211208225711162](Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.photo/image-20211208225711162.png)

#### 2.3 SDS API

![image-20211208225931735](Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.photo/image-20211208225931735.png)

#### 2.4 重点回顾

- Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS（Simple Dynamic String，简单动态字符串）作为字符串表示。

- 比起C字符串，SDS具有以下优点：
  - 常数复杂度获取字符串长度。
  - 杜绝缓冲区溢出。
  - 减少修改字符串长度时所需的内存重分配次数。
  - 二进制安全。
  - 兼容部分C字符串函数。

### 第3章 链表

### 第4章 字典

### 第5章 跳跃表

### 第6章 整数集合

### 第7章 压缩列表

### 第8章 对象