# 代码整洁之道

## 第1章　整洁代码　1

### 1.1　要有代码　2

代码是用于表达需求的语言

### 1.2　糟糕的代码　2

糟糕的代码就像沼泽，写得越多陷得越深

### 1.3　混乱的代价　3

随着时间推移，混乱的代码让开发的效率直线下滑，

#### 1.3.1　华丽新设计　4

当代码乱到一定程度，就需要从新设计一套新系统，代码不止关乎效率，还关乎生存

#### 1.3.2　态度　4

经理会希望得到实情，经理和程序员都应该拥有相同维护代码的热情

#### 1.3.3　迷题　5

混乱会拖开发的后退，背负越大的压力越容易制造混乱，但制造混乱无助于赶上期限

#### 1.3.4　整洁代码的艺术　5

写代码需要大量的小技巧，保持“代码感”能过帮助程序员选出最好的方案

#### 1.3.5　什么是整洁代码　6

### 1.4　思想流派　10

本书是代码整洁派

### 1.5　我们是作者　11

读代码的时间远远超过写代码的时间，想要干得快，需要让代码足够易读

### 1.6　童子军军规　12

时时刻刻保持代码的整洁。

努力，让世界比你来之前更干净

#### 1.8　小结　12

书籍会充满细节，你会看到启发，规条和技巧的列表，但最终的结果取决于你自己

#### 

## 第2章　有意义的命名　15

### 2.1　介绍　15

### 2.2　名副其实　16

代码其实就在他该在的地方，所以命名一定要有意义（可以借助IDE多次重命名）

比如：无意义的List改成gameBoard，或者将 == 转换成一个函数isFlagged()

### 2.3　避免误导　17

采取同样的方式拼写出同样的概念才是信息，拼写不一致就是误导

accountList不一定是List，还不如用accountGroup或者bunchOfAccount

不要使用外形相似度极高的名称！

0和o，O不要混用

### 2.4　做有意义的区分　18

不要命名为a1,a2,an

不要写废话：比如Product，ProductInfo，ProductData都是一个意思

getAccount()，getAccountInfo()也是一个意思

variable不要出现在变量名称中，table不要出现在表名字中

### 2.5　使用读得出来的名称　19

用英文词，不要用音译或者难以得到其原本想法的词

### 2.6　使用可搜索的名称　20

名称的长短应该与他的作用域大小相对应。

用一个常量（7）不如给他定义成名称为MAX_CLASS类似的常量来使用

### 2.7　避免使用编码　21

没必要把类型或者作用域编写入代码

#### 2.7.1　匈牙利语标记法　21

常常会将类型放置于名称之前，比如bBusy，就是个bool类型的变量

#### 2.7.2　成员前缀　21

不必要使用m_前缀来表明成员变量，应该把类和函数做的足够小，来消除对成员前缀的需求

#### 2.7.3　接口和实现　22

创建一个接口，不要加 I 来修饰。不如改成ShapeFactory与ShapeFactoryImp

### 2.8　避免思维映射　22

明确才是王道

少用i，j，k或者用某个字母代表某个变量

### 2.9　 类名　23

类名和对象名应该是名词或者名词短语

比如：Customer，WikiPage，Account

避免使用Manager，Processor，Data或者Info这样子的类名

### 2.10　方法名　23

方法名应该是动词或者动词短语

比如postPayment，deletePage

属性访问器，修改器和断言应该根据他的名字进行命名，比如在前缀加上get，set，is

重载构造器的时候，使用描述了参数的静态工厂方法名字

比如Complex.FromRealNumber(12,0)好过new Complex(12,0)

### 2.11　别抖机灵　23

不要用俚语或者俗话来作为名称

### 2.12　每个概念对应一个词　24

给每个抽象的概念选一个词，并一以贯之

比如使用fetch,retrieve和get来给多个类中的同种方法命名

### 2.13　别用双关语　24

一词一义，没必要为了保持一致而用之前的名称。比如经常用add，没必要在一个个体插入群体的语境使用add，应该用append或者insert

### 2.14　使用解决方案领域名称　25

应该通过名称就能知道你使用的概念，比如AccountVisitor富有意义

### 2.15　使用源自所涉问题领域的名称　25

采用来自所涉及的问题领域的名称

### 2.16　添加有意义的语境　25

对于同一代码块很多的命名，尝试使用一个类把他们统一起来

### 2.17　不要添加没用的语境　27

没必要加没有意义的前缀，比如全都用项目名称的缩写作为前缀

## 第3章　函数　29

### 3.1　短小　32

### 3.2　只做一件事　33

### 3.3　每个函数一个抽象层级　34

### 3.4　switch语句　35

### 3.5　使用描述性的名称　36

### 3.6　函数参数　37

#### 3.6.1　一元函数的普遍形式　38

#### 3.6.2　标识参数　38

#### 3.6.3　二元函数　38

#### 3.6.4　三元函数　39

#### 3.6.5　参数对象　39

#### 3.6.6　参数列表　40

#### 3.6.7　动词与关键字　40

### 3.7　无副作用　40

### 3.8　分隔指令与询问　42

### 3.9　使用异常替代返回错误码　42

#### 3.9.1　抽离Try/Catch代码块　43

#### 3.9.2　错误处理就是一件事　44

#### 3.9.3　Error.java依赖磁铁　44

### 3.10　别重复自己　44

### 3.11　结构化编程　45

### 3.12　如何写出这样的函数　45

### 3.13　小结　45

### 3.14　SetupTeardownIncluder程序　46

### 3.15　文献　48

## 第4章　注释　49

### 4.1　注释不能美化糟糕的代码　50

### 4.2　用代码来阐述　51

### 4.3　好注释　51

#### 4.3.1　法律信息　51

#### 4.3.2　提供信息的注释　51

#### 4.3.3　对意图的解释　52

#### 4.3.4　阐释　53

#### 4.3.5　警示　53

#### 4.3.6　TODO注释　54

#### 4.3.7　放大　54

#### 4.3.8　公共API中的Javadoc　55

### 4.4　坏注释　55

#### 4.4.1　喃喃自语　55

#### 4.4.2　多余的注释　56

#### 4.4.3　误导性注释　58

#### 4.4.4　循规式注释　58

#### 4.4.5　日志式注释　59

#### 4.4.6　废话注释　59

#### 4.4.7　可怕的废话　61

#### 4.4.8　能用函数或变量时就别用注释　62

#### 4.4.9　位置标记　62

#### 4.4.10　括号后面的注释　62

#### 4.4.11　归属与署名　63

#### 4.4.12　注释掉的代码　63

#### 4.4.13　HTML注释　64

#### 4.4.14　非本地信息　64

#### 4.4.15　信息过多　65

#### 4.4.16　不明显的联系　65

#### 4.4.17　函数头　66

#### 4.4.18　非公共代码中的Javadoc　66

#### 4.4.19　范例　66

### 4.5　文献　69

## 第5章　格式　71

### 5.1　格式的目的　72

### 5.2　垂直格式　72

#### 5.2.1　向报纸学习　73

#### 5.2.2　概念间垂直方向上的区隔　73

#### 5.2.3　垂直方向上的靠近　74

#### 5.2.4　垂直距离　75

#### 5.2.5　垂直顺序　79

### 5.3　横向格式　79

#### 5.3.1　水平方向上的区隔与靠近　80

#### 5.3.2　水平对齐　81

#### 5.3.3　缩进　82

#### 5.3.4　空范围　84

### 5.4　团队规则　84

### 5.5　鲍勃大叔的格式规则　85

## 第6章　对象和数据结构　87

### 6.1　数据抽象　87

### 6.2　数据、对象的反对称性　89

### 6.3　得墨忒耳律　91

#### 6.3.1　火车失事　91

#### 6.3.2　混杂　92

#### 6.3.3　隐藏结构　92

### 6.4　数据传送对象　93

### 6.5　小结　94

### 6.6　文献　94

## 第7章　错误处理　95

### 7.1　使用异常而非返回码　96

### 7.2　先写Try-Catch-Finally语句　97

### 7.3　使用不可控异常　98

### 7.4　给出异常发生的环境说明　99

### 7.5　依调用者需要定义异常类　99

### 7.6　定义常规流程　100

### 7.7　别返回null值　101

### 7.8　别传递null值　102

### 7.9　小结　103

### 7.10 文献　104

## 第8章　边界　105

### 8.1　使用第三方代码　106

### 8.2　浏览和学习边界　107

### 8.3　学习log4j　108

### 8.4　学习性测试的好处不只是免费　110

### 8.5　使用尚不存在的代码　110

### 8.6　整洁的边界　111

### 8.7　文献　112

## 第9章　单元测试　113

### 9.1　TDD三定律　114

### 9.2　保持测试整洁　115

### 9.3　整洁的测试　116

#### 9.3.1　面向特定领域的测试语言　118

#### 9.3.2　双重标准　119

### 9.4　每个测试一个断言　121

#### 9.5　F.I.R.S.T.　122

#### 9.6　小结　123

#### 9.7　文献　124

## 第10章　类　125

#### 10.1　类的组织　126

### 10.2　类应该短小　126

#### 10.2.1　单一权责原则　128

#### 10.2.2　内聚　129

#### 10.2.3　保持内聚性就会得到许多短小的类　130

### 10.3　为了修改而组织　136

### 10.4　文献　139

## 第11章　系统　141

### 11.1　如何建造一个城市　142

### 11.2　将系统的构造与使用分开　142

#### 11.2.1　分解main　143

#### 11.2.2　工厂　143

#### 11.2.3　依赖注入　144

### 11.3　扩容　145

### 11.4　Java代理　148

### 11.5　纯Java AOP框架　150

### 11.6　AspectJ的方面　152

### 11.7　测试驱动系统架构　153

### 11.8　优化决策　154

### 11.9　明智使用添加了可论证价值的标准　154

### 11.10　系统需要领域特定语言　154

### 11.11　小结　155

### 11.12　文献　155

## 第12章　迭进　157

### 12.1　通过迭进设3计达到整洁目的　157

### 12.2　简单设计规则1：运行所有测试　158

### 12.3　简单设计规则2～4：重构　158

### 12.4　不可重复　159

### 12.5　表达力　161

### 12.6　尽可能少的类和方法　162

### 12.7　小结　162

### 12.8　文献　162

## 第13章　并发编程　163

### 13.1　为什么要并发　164

### 13.2　挑战　165

### 13.3　并发防御原则　166

#### 13.3.1　单一权责原则　166

#### 13.3.2　推论：限制数据作用域　166

#### 13.3.3　推论：使用数据复本　167

#### 13.3.4　推论：线程应尽可能地独立　167

### 13.4　了解Java库　167

### 13.5　了解执行模型　168

#### 13.5.1　生产者-消费者模型　169

#### 13.5.2　读者-作者模型　169

#### 13.5.3　宴席哲学家　169

### 13.6　警惕同步方法之间的依赖　169

### 13.7　保持同步区域微小　170

### 13.8　很难编写正确的关闭代码　170

### 13.9　测试线程代码　171

#### 13.9.1　将伪失败看作可能的线程问题　171

#### 13.9.2　先使非线程代码可工作　171

#### 13.9.3　编写可插拔的线程代码　172

#### 13.9.4　编写可调整的线程代码　172

#### 13.9.5　运行多于处理器数量的线程　172

#### 13.9.6　在不同平台上运行　172

#### 13.9.7　装置试错代码　173

#### 13.9.8　硬编码　173

#### 13.9.9　自动化　174

### 13.10　小结　175

#### 13.11　文献　175

## 第14章　逐步改进　176

### 14.1　Args的实现　177

### 14.2　Args：草稿　183

#### 14.2.1　所以我暂停了　195

#### 14.2.2　渐进　195

### 14.3　字符串参数　197

### 14.4　小结　234

## 第15章　JUnit内幕　235

### 15.1　JUnit框架　236

### 15.2　小结　249

## 第16章　重构SerialDate　251

### 16.1　首先，让它能工作　252

### 16.2　让它做对　254

### 16.3　小结　266

### 16.4　文献　267

## 第17章　味道与启发　269

### 17.1　注释　270

### 17.2　环境　271

### 17.3　函数　271

### 17.4　一般性问题　272

### 17.5　Java　288

### 17.6　名称　291

### 17.7　测试　294

### 17.8　小结　295

### 17.9　文献　296

## 附录A　并发编程II　297

### A.1　客户端/服务器的例子　297

#### A.1.1　服务器　297

#### A.1.2　添加线程代码　298

#### A.1.3　观察服务器端　299

#### A.1.4　小结　301

### A.2　执行的可能路径　301

#### A.2.1　路径数量　302

#### A.2.2　深入挖掘　303

#### A.2.3　小结　305

### A.3　了解类库　305

#### A.3.1　Executor框架　305

#### A.3.2　非锁定的解决方案　306

#### A.3.3　非线程安全类　307

### A.4　方法之间的依赖可能破坏并发代码　308

#### A.4.1　容忍错误　309

#### A.4.2　基于客户代码的锁定　309

#### A.4.3　基于服务端的锁定　311

### A.5　提升吞吐量　312

#### A.5.1　单线程条件下的吞吐量　313

#### A.5.2　多线程条件下的吞吐量　313

### A.6　死锁　314

#### A.6.1　互斥　315

#### A.6.2　上锁及等待　315

#### A.6.3　无抢先机制　315

#### A.6.4　循环等待　315

#### A.6.5　不互斥　316

#### A.6.6　不上锁及等待　316

#### A.6.7　满足抢先机制　317

#### A.6.8　不做循环等待　317

### A.7　测试多线程代码　317

### A.8　测试线程代码的工具支持　320

### A.9　小结　320

### A.10 教程：完整代码范例　321

#### A.10.1　客户端/服务器非线程代码　321

#### A.10.2　使用线程的客户端/服务器代码　324